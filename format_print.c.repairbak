#include "main.h"
#include "num_helpers.h"


/* helpers inside this file */
static int emit_prefix(const char *pfx)
{
	int n = 0;
	int k;

	while (pfx != 0 && *pfx != '\0')
	{
		k = _putchar(*pfx++);
		if (k == -1)
			return (-1);
		n++;
	}
	return (n);
}

static int print_str_fmt(const char *s, int width, int precision, int f_minus)
{
	int k, out = 0;
	int slen, pad;

	if (s == 0)
		s = "(null)";
	slen = (int)strnlen_prec(s, precision);
	pad = (width > slen) ? (width - slen) : 0;

	if (!f_minus && pad)
	{
		k = putnchar(' ', pad);
		if (k == -1)
			return (-1);
		out += k;
	}

	while (slen--)
	{
		if (_putchar(*s++) == -1)
			return (-1);
		out++;
	}

	if (f_minus && pad)
	{
		k = putnchar(' ', pad);
		if (k == -1)
			return (-1);
		out += k;
	}

	return (out);
}

/* core numeric formatter for diouxXp and b (unsigned) */
int print_formatted(const fmt_t *f_in, va_list *ap)
{
	fmt_t f = *f_in;
	int out = 0, k;

	/* normalize width/precision */
	if (f.width < 0)
	{
		f.f_minus = 1;
		f.width = -f.width;
	}
	if (f.precision < 0)
		f.precision = -1;

	/* strings */
	if (f.spec == 's')
		return (print_str_fmt(va_arg(*ap, char *), f.width, f.precision, f.f_minus));

	/* chars */
	if (f.spec == 'c')
	{
		int pad = (f.width > 1) ? f.width - 1 : 0;
		char ch = (char)va_arg(*ap, int);
		char padc = (!f.f_minus && f.f_zero) ? '0' : ' ';

		if (!f.f_minus && pad)
		{
			k = putnchar(padc, pad);
			if (k == -1)
				return (-1);
			out += k;
		}
		if (_putchar(ch) == -1)
			return (-1);
		out++;
		if (f.f_minus && pad)
		{
			k = putnchar(' ', pad);
			if (k == -1)
				return (-1);
			out += k;
		}
		return (out);
	}

	/* literal percent */
	if (f.spec == '%')
	{
		int pad = (f.width > 1) ? f.width - 1 : 0;
		char padc = (!f.f_minus && f.f_zero) ? '0' : ' ';

		if (!f.f_minus && pad)
		{
			k = putnchar(padc, pad);
			if (k == -1)
				return (-1);
			out += k;
		}
		if (_putchar('%') == -1)
			return (-1);
		out++;
		if (f.f_minus && pad)
		{
			k = putnchar(' ', pad);
			if (k == -1)
				return (-1);
			out += k;
		}
		return (out);
	}

	/* custom you already have */
	if (f.spec == 'S')
		return (print_S(va_arg(*ap, char *)));
	if (f.spec == 'r')
		return (print_rev(va_arg(*ap, char *)));
	if (f.spec == 'R')
		return (print_rot13(va_arg(*ap, char *)));
	if (f.spec == 'p')
		return (print_pointer(va_arg(*ap, void *)));
	if (f.spec == 'b')
	{
		unsigned int bv = va_arg(*ap, unsigned int);

		return (print_base((unsigned long)bv, 2, 0));
	}

	/* ----- numeric (d i u o x X) with flags/width/precision/length ----- */
	{
		int is_signed = (f.spec == 'd' || f.spec == 'i');
		int base = 10;
		int upper = 0;
		unsigned long uval = 0;
		long sval = 0;
		int neg = 0;
		char prefix[3];
		int body = 0;
		int zeros = 0;
		int pad = 0;


		prefix[0] = '\0';
		prefix[1] = '\0';
		prefix[2] = '\0';

tif (f.spec == 'o')
		base = 8;
	else if (f.spec == 'x' || f.spec == 'X')
	{
		base = 16;
		upper = (f.spec == 'X');
	}

	/* length pick */
		if (is_signed)
		{
			if (f.length == 2)
				sval = va_arg(*ap, long);
			else if (f.length == 1)
				sval = (short)va_arg(*ap, int);
			else
				sval = va_arg(*ap, int);

			if (sval < 0)
			{
				neg = 1;
				uval = (unsigned long)(-sval);
			}
			else
			{
				uval = (unsigned long)sval;
				if (f.f_plus)
					prefix[0] = '+';
				else if (f.f_space)
					prefix[0] = ' ';
			}
		}
		else
		{
			if (f.length == 2)
				uval = va_arg(*ap, unsigned long);
			else if (f.length == 1)
				uval = (unsigned long)((unsigned short)va_arg(*ap, unsigned int));
			else
				uval = (unsigned long)va_arg(*ap, unsigned int);
		}

		/* precision overrides zero-pad */
		if (f.precision != -1)
			f.f_zero = 0;

		/* number of digits */
		{
			unsigned long t = uval;

			if (t == 0)
				body = 1;
			while (t > 0)
			{
				body++;
				t /= (unsigned long)base;
			}
		}

		/* special case: precision ".0" and value is 0 => print nothing */
		if (uval == 0 && f.precision == 0)
			body = 0;

		/* hash prefix */
		if (f.f_hash && uval != 0)
		{
			if (base == 8)
				prefix[0] = '0';
			else if (base == 16)
			{
				prefix[0] = '0';
				prefix[1] = upper ? 'X' : 'x';
			}
		}
		/* %.0o with value 0 prints single '0' when '#' is set */
		if (base == 8 && f.f_hash && uval == 0 && f.precision == 0)
			body = 1;

		/* precision zeros */
		if (f.precision > body)
			zeros = f.precision - body;

		/* width calculation (sign or 0x included as prefix size) */
		{
			int pfx = 0;

			if (neg)
				pfx = 1;
			else if (prefix[0] != '\0')
				pfx = (prefix[1] != '\0') ? 2 : 1;

			if (f.width > body + zeros + pfx)
				pad = f.width - (body + zeros + pfx);
		}

		/* zero-pad only applies when no precision and not left-justified */
		if (!f.f_minus && f.f_zero && f.precision == -1 && pad > 0)
		{
			zeros += pad;
			pad = 0;
		}

		/* left pad */
		if (!f.f_minus && pad > 0)
		{
			k = putnchar(' ', pad);
			if (k == -1)
				return (-1);
			out += k;
		}

		/* sign / prefix */
		if (neg)
		{
			if (_putchar('-') == -1)
				return (-1);
			out++;
		}
		else
		{
			k = emit_prefix(prefix);
			if (k == -1)
				return (-1);
			out += k;
		}

		/* zeros (from precision or zero pad) */
		if (zeros > 0)
		{
			k = putnchar('0', zeros);
			if (k == -1)
				return (-1);
			out += k;
		}

		/* digits (unless suppressed by .0 with value 0) */
		if (body > 0)
		{
			/* print number into a temp buffer reversed */
			char buf[64];
			int bi = 0;
			unsigned long t = uval;

			if (t == 0)
				buf[bi++] = '0';
			while (t > 0)
			{
				int d = (int)(t % (unsigned long)base);

				if (d < 10)
					buf[bi++] = (char)('0' + d);
				else
					buf[bi++] = (char)((upper ? 'A' : 'a') + (d - 10));
				t /= (unsigned long)base;
			}
			while (bi--)
			{
				if (_putchar(buf[bi]) == -1)
					return (-1);
				out++;
			}
		}

		/* right pad */
		if (f.f_minus && pad > 0)
		{
			k = putnchar(' ', pad);
			if (k == -1)
				return (-1);
			out += k;
		}

		return (out);
	}
}

/* Fallback: unknown specifier => print it literally as %<spec> */
}

